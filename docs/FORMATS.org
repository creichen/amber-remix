* AmberStar Formats

AmberStar encodes its data in formats that are similar, but not
universally cases identical to the AmberMoon formats.  This document
attempts to be comprehensive at re-iterating all relevant format
descriptions and assumes no prior knowledge of the AmberMoon formats
as collected by Pyrdacor: [[https://github.com/Pyrdacor/Ambermoon]] .

* Application Notes

When using these notes to implement an AmberStar interface, please
make note of the limitations and practical considerations listed
below.

** Limitations

- The discussion in this file is for the Amiga file formats only.  The
  PC/DOS version of the game uses different formats.  (Some files may
  or may not have an identical format.)

- The descriptions below works for the English version of the game.
  The German version seems to use the same formats, but hasn't seen
  the same degree of validation (especially wrt text encodings).

- As of early 2022, the copyright holder(s) and status of AmberStar
  are unknown.  The most likely entities in possession of this
  copyright have declined to investigate this question due to a lack
  of commercial interest.

- This document makes no claim(s) to completeness, soundness, or
  fitness for a specific purpose, expressed or implied.

** Practical Notes: Endianness and Alignment

- Unless noted otherwise, all numbers are encoded in big-endian two's
  complement format (e.g., a 16 bit representation of the number 1000
  is encoded as the two bytes ~03e8~).

- Numbers need not be aligned to word boundaries.  Trying to read
  unaligned numbers with a 16 bit or 32 bit memory read may produce
  unexpected results on some CPUs.  (In C and C++, unaligned loads
  depend on parts of the language semantics that are explicitly
  undefined, so if in doubt, make use to read each byte individually
  and reassemble later.)

* Sources

The information below is based on educated guesses, general
information about the Amiga and about AmberStar that are publicly
available, plus the following sources:
- Prior efforts to decode the sequel, Ambermoon: [[https://github.com/Pyrdacor/Ambermoon]]
- Assembly code for Hippel-CoSo and Hippel-V7 shipped with UADE:  https://zakalwe.fi/uade/

* Container Formats

AmberStar encodes most of its data in _container files_, each of which
contains a number of additional resources.  The formats are as follows
(using AmberMoon naming conventions):
- ~LOB~ (single file, compressed)
- ~AMBR~ (multi-file container, uncompressed)
- ~AMPC~ (multi-file container, optionally compressed)

A few files are ~raw~ files, i.e., stored without a surrounding
container; we can read them directly.

Below is an overview of the relevant files. Files without a
"Container" are ~raw~ files.

| File         | Container | Elements | Format                   | Explanation                   | Decoded                           |
|--------------+-----------+----------+--------------------------+-------------------------------+-----------------------------------|
| AMBERDEV.UDO | LOB       |        1 | Many (incl. Hippel-CoSo) | Assortment of data            | only very partially               |
| Amberload    |           |          |                          |                               |                                   |
| AUTOMAP.AMB  | AMBR      |      152 |                          |                               |                                   |
| BACKGRND.AMB | AMPC      |       10 | BITMAP_4 144x144 (?)     | Town (+dungeon) backgrounds   | only partially, palettes missing  |
| CHARDATA.AMB | AMBR      |       78 |                          |                               |                                   |
| CHESTDAT.AMB | AMPC      |      163 |                          |                               |                                   |
| CODETXT.AMB  | AMBR      |        2 | TEXT                     |                               | yes                               |
| COL_PALL.AMB | AMBR      |       10 | PALETTE_HD               |                               | mostly, missing exact RGB mapping |
| COM_BACK.AMB | AMPC      |       14 | BITMAP_4 176x112         | Combat background images      | Missing palettes                  |
| EXTRO.UDO    |           |          | (incl. Hippel-7V)        |                               |                                   |
| F_T_ANIM.ICN |           |          |                          |                               |                                   |
| ICON_DAT.AMB | AMPC      |        2 | ICON_DAT                 | Map tile graphics             | partially                         |
| INTRO_P.UDO  | LOB       |        1 | (incl. Hippel-7V)        |                               |                                   |
| INTRO.UDO    | LOB       |        1 |                          |                               |                                   |
| LABBLOCK.AMB | AMPC      |       68 |                          |                               |                                   |
| LAB_DATA.AMB | AMBR      |       23 |                          |                               |                                   |
| MAP_DATA.AMB | AMPC      |      152 |                          |                               |                                   |
| MAPTEXT.AMB  | AMBC      |      152 | TEXT                     |                               | yes                               |
| MON_DATA.AMB | AMBR      |       67 |                          |                               |                                   |
| MON_GFX.AMB  | AMPC      |       21 |                          |                               |                                   |
| PARTYDAT.SAV |           |          |                          |                               |                                   |
| PICS80.AMB   | AMPC      |       52 | PICS80                   |                               | mostly, missing palette bindings  |
| PUZZLE.ICN   |           |          |                          |                               |                                   |
| PUZZLE.TXT   |           |          |                          |                               |                                   |
| SAMPLEDA.IMG |           |          | PCM                      | Sample data for in-game songs | yes                               |
| TACTIC.ICN   |           |          |                          |                               |                                   |
| TH_LOGO.UDO  | LOB       |        1 |                          |                               |                                   |
| WARESDAT.AMB | AMPC      |       16 |                          |                               |                                   |


The AmberStar container formats are a strict subset of the AmberMoon
formats, so AmberMoon tools should work fine for handling AmberStar
containers.  The rest of this section details the AmberStar formats
(only), for completeness.

** Automatically Identifying Containers

Each container starts with the following 4-byte header (expressed as a
C string):

| Container | Header      |
|-----------+-------------|
| ~LOB~     | ~"\x01LOB"~ |
| ~AMBR~    | ~"AMBR"~    |
| ~AMPC~    | ~"AMPC"~    |

Raw files do (coincidentally?) not match these headers.

** ~LOB~ Container format

~LOB~ files have the format:

| Name       | Format  | Comments          |
|------------+---------+-------------------|
| header     | u8[4]   | always  ~\x01LOB~ |
| 6          | u8      | constant ~6~      |
| raw_size   | u24     |                   |
| compressed | u8[...] | until end of file |

Each ~LOB~ file stores one piece of compressed data.  ~raw_size~ is
the size of the output data after decompression.  The compressed data
follows the _LOB compression_ scheme described below.

*Implementation Note*: When reading raw_size as ~u32~, make sure to
mask out the most significant byte (the constant ~06~ byte).

*** LOB Compression

The LOB compression scheme is detailed here:
[[https://github.com/Pyrdacor/Ambermoon/blob/master/Files/LOB.md]]

Summary below:

LOB compression is an LZ77-style compression scheme that encodes data
by giving a sequence of either literal bytes or back-references to
previously decoded data.  Conceptually, it is a stream of instructions
that describe how to grow an (initially empty) output buffer:

- ~BYTE(b)~: Append ~b~ to the output buffer, ~out[pos++] = b~ in C notation
- ~BACKREF(p, l)~:  Append ~l~ previously decoded bytes, starting at ~out[pos - p]~, to the output buffer

These instructions are encoded in _chunks_, where each chunk consists of:
- 1 header byte
- 8 instructions (possibly fewer, at the end of the stream)

The header byte is a bitmask in which each bit describes the type of
the 8 following instructions, in order from MSB to LSB:
- 0: instruction is ~BACKREF(p, l)~, encoded as two bytes with nibbles ~WX YZ~ such that ~l = X+3~ and ~p = WYZ~
- 1: instruction is ~BYTE(b)~, encoded simply as ~b~

Thus, a chunk is encoded as a sequence of 9 to 17 bytes, unless it is
at the end of a stream.

Decompression ends as soon as the output buffer is full.

** ~AMBR~ Container Format

| Name                      | Format                      | Comments       |
|---------------------------+-----------------------------+----------------|
| header                    | u8[4]                       | always  ~AMBR~ |
| num_elements              | u16                         |                |
| sizes                     | u32[num_elements]           |                |
| element[0]                | u8[sizes[0]]                | raw data       |
| ...                       |                             |                |
| element[num_elements - 1] | u8[sizes[num_elements - 1]] | raw data       |

This uncompressed format is straightforward, though it is oddly
inefficient, in that looking up one element requires adding up the
sizes of all preceding elements to find that element's offset.

** ~AMPC~ Container Format

| Name                            | Format                      | Comments              |
|---------------------------------+-----------------------------+-----------------------|
| header                          | u8[4]                       | always  ~AMPC~        |
| num_elements                    | u16                         |                       |
| sizes                           | u32[num_elements]           |                       |
| element_block[0]                | u8[sizes[0]]                | LOB-compressed or raw |
| ...                             |                             |                       |
| element_block[num_elements - 1] | u8[sizes[num_elements - 1]] | LOB-compressed or raw |

~AMPC~ is similar to ~AMBR~, except that instead of directly storing
raw data, it may also store LOB-compressed data (see above).  An
~element_block~ can thus be in one of:
- ~LOB block~ format
- ~raw~ format

The block is in ~LOB block~ format iff it matches the following format:

| Name            | Format              | Comments          |
|-----------------+---------------------+-------------------|
| header          | u8[4]               | always  ~\x01LOB~ |
| 6               | u8                  | constant ~6~      |
| raw_size        | u24                 |                   |
| compressed_size | u32                 |                   |
| compressed      | u8[compressed_size] |                   |

Otherwise, the block is ~raw~, as in ~AMBR~ (implying that raw data
must never "accidentally" start with the ~LOB~ header).

* AMBERDEV data

The ~AMBERDEV~ file contains a large assortment of data (and possibly executable code?).  Some known
bits of interest below:

| Start offset    | Description                     | Format                                       |
|-----------------+---------------------------------+----------------------------------------------|
| 2170b           | String Fragment Table           | cf. Text Encoding                            |
| 31a46           | Song names                      | 0-terminated string, terminated by another 0 |
| 33d70 (approx.) | Graphics                        | 16x16, details tbd                           |
| 4cdc0           | Songs, starting with"City Walk" | CoSo                                         |

** String Fragment Table

The String Fragment Table is a sequence of strings that are each
preceded by a single byte indicating the string's length plus one.
For instance, the string "ELF" is preceded by ~04~.  The last string
is followed by a ~00~ byte.  These strings form an indexable table of
English/German words:

| Index | Word    |
|-------+---------|
|     1 | ~HUMAN~ |
|     2 | ~ELF~   |
|     3 | ~DWARF~ |
|   ... | ...     |

The special character ~#~ indicates a newline.

The German version of the game presumably uses codepage 850 for German
characters (?).

* Text Encoding

Text is generally encoded as a sequence of u16 indices into the String
Fragment Table.  Since this sequence does not include whitespace,
decoding text requires inserting whitespace at certain positions.

The following heuristic may or may not produce the desired results:
- When decoding, Insert a blank before the next string fragment if:
  - The next fragment is NOT the first fragment in the text
  - The previous fragment was NOT a newline
  - The next fragment starts with a letter, a number, a dash or a tilde symbol

** TEXT Format

The ~TEXT~ format describes a table of strings that use _Text Encoding_.  It consists
either of two ~00~ bytes, indicating that the table is empty, or of the following:

| Name               | Format                                 |
|--------------------+----------------------------------------|
| num_text           | u8                                     |
| 0                  | u8                                     |
| pos[0]             | u16                                    |
| ...                | ...                                    |
| pos[num_text]      | u16                                    |
| text[0]            | u16[pos[1] - pos[0]]                   |
| ...                |                                        |
| text[num_text - 1] | u16[pos[num_text] - pos[num_text - 1]] |

Note that there are ~num_text + 1~ text position entries, but only
~num_text~ texts; this simplifies determining how long each text is.
Each text is encoded with the _Text Encoding_ format described above.


* Graphics

** BITMAP_4 format

(Used by PICS80)

4 bitplanes.  Format:

(assuming 80x80 images)

- 80 lines containing:
  - 5 x-words containing:
    - 4 bitplanes (bit 0 to bit 3):
      - one u16 (MSB left) that encodes that bitplane for the current x-word.


For example, the first two lines of an 80x(something) image will consist of ten
x-words, each describing 16 pixels:

00000000000000001111111111111111222222222222222233333333333333334444444444444444
55555555555555556666666666666666777777777777777788888888888888889999999999999999
...

Each of these is encoded as a sequence of 4 16 bit words:
- bitplane[0] : u16
- bitplane[1] : u16
- bitplane[2] : u16
- bitplane[3] : u16

** PALETTE_HDR format
(used by COL_PALL and ICON_DAT)

Starts with a 16 bit word that indicates the number of colours.
Otherwise analogous to PALETTE_16, though colour indices seem to go
only up to 7 (?) in ICON_DAT.

** PALETTE_16 format

(Used by PICS80)

Same as in AmberMoon.  16 colours, with each palette entry encoded as
two bytes / four nibbles: ~XR GB~, where ~X~ is always 0.  ~R~, ~G~,
and ~B~ range from ~0~ (minimum) to ~f~ (maximum).

** PICS80 Format

Contains 26 80x80 pixel images.  Each image is encoded as a bitmap and a palette, with
image ~n~ stored as:
- BITMAP_4 at ~PICS80[n*2]~
- PALETTE_16 at ~PICS80[n*2 + 1]~

| Image number | Showing                                      | Meaning       | Notes        | Alt PIC80 palette |
|--------------+----------------------------------------------+---------------+--------------+-------------------|
|            0 | Camp                                         |               |              |                   |
|            1 | Graveyard                                    | Start of game |              |                   |
|            2 | Inn                                          |               |              |                   |
|            3 | Store                                        |               |              |                   |
|            4 | Basement lab                                 |               |              |                   |
|            5 | Monster with a sword                         |               | Bad palette? | 27 ??             |
|            6 | Stable                                       |               |              |                   |
|            7 | Temple                                       |               |              |                   |
|            8 | Rat altar                                    |               |              |                   |
|            9 | Bearded guy with books in his home           |               |              |                   |
|           10 | Robed person on round throne                 |               |              |                   |
|           11 | Closed chest                                 |               |              |                   |
|           12 | Door                                         |               |              |                   |
|           13 | Pier and ship                                |               |              |                   |
|           14 | Bar                                          |               |              |                   |
|           15 | Cultist ceremony                             |               | Bad palette? | 9? 21?            |
|           16 | Magic mouth                                  |               |              |                   |
|           17 | Dead people in forest                        |               |              |                   |
|           18 | Wizard casting Force Cage on group of people |               |              |                   |
|           19 | Dragon with nest                             |               |              |                   |
|           20 | Opened chest                                 |               |              |                   |
|           21 | Crystal ball with island inside              |               |              |                   |
|           22 | Robed man in library                         |               |              |                   |
|           23 | Demon in crystal ball                        |               |              |                   |
|           24 | Volcano and castle                           |               | Bad palette? |                   |
|           25 | Hand holding something (the AmberStar?)      |               | Bad palette? |                   |

** ICON_DAT

This format describes graphics for map tiles ("map tile icons").  Both
container elements describe 250 (0xfa) map icons.  The file format is
as follows:

| Name                 | Format          | Comments                           |
|----------------------+-----------------+------------------------------------|
| ?                    | u16             | Unknown values are (0xed and 0xf9) |
| animation_type[250]  | u8[250]         | (not verified)                     |
| animation_start[250] | u16[250]        | (not verified)                     |
| ?                    | u32[250]        | Seemingly bit flags for each icon  |
| ?                    | u8(250]         | Small numbers (0-10) for each icon |
| palette              | PALETTE_HDR     | 66 bytes                           |
| images               | BITMAP_HDR[250] | starts at 0x814                    |

Note that icons may consist of (loop over) multiple images.

- ~animation_type~: Unclear.  Seems to take values 1-4, 6, and 7.  Some observations:
  - ~1~: seems to be used for static images
  - ~2~: used for three images of a person sitting on a chair, looking
    in different directions, perhaps adjusted to look at the player
    character?
  - ~3~: used for what appears to be a gate opening animation
  - ~4~: looping?
  - ~6~: used for a bursting bubble
  - ~7~: used for a bursting bubble

- ~animation_start~: indicates for each icon what the first image for
  that icon is.  ~animation_start[icon] = img~ means that the icon
  uses the images between:
  - first: ~images[img - 1]~
  - last: ~images[animation_start[icon + 1] - 1]~, except for the last icon,
    which always seems to have only one image.
  (i.e., ~images[0]~ is encoded as ~1~ in this table).


** Graphics files

* Songs

Song information for all songs other than intro and outro is split up
into _sample data_ (SAMPLEDA.IMG) and individual songs stored in
AMBERDEV.UDO.  At this time it is unclear where the song locations are
indexed, but since there are exactly 19 CoSo song headers for the 19
songs, it is unlikely that this needs to be addressed.

** SAMPLEDA Format

This file contains signed 8-bit sample data.  It is indexed from CoSo
*Sample* records.

** CoSo Format

The description below focuses on the Hippel-CoSo variant used in
AmberStar.  See "CoSo Notes" below for more information.

A CoSo record starts with the following header:

| Name                 | Format | Comments                       |
|----------------------+--------+--------------------------------|
| magic number         | u8[4]  | always  ~COSO~                 |
| pos_instruments      | u32    |                                |
| pos_timbres          | u32    |                                |
| pos_monopatterns     | u32    |                                |
| pos_divisions        | u32    |                                |
| pos_song             | u32    |                                |
| pos_samples          | u32    |                                |
| total_length         | u32    |                                |
| magic number         | u8[4]  | always  ~TFMX~                 |
| num_instruments - 1  | u2     |                                |
| num_timbres - 1      | u2     | 1 less than the actual count   |
| num_monopatterns - 1 | u2     | 1 less than the actual count   |
| num_divisions - 1    | u2     | 1 less than the actual count   |
| 0x40                 | u2     | unknown / unused               |
| 0                    | u2     | unknown / unused               |
| num_songs            | u2     |                                |
| num_samples          | u2     |                                |
| 0                    | u2[6]  | unknown / unused (!unverified) |


All ~pos_~ references are relative to the first byte of the header.

The remaining song data (except for the sample data) follows.

*** CoSo Sections

A CoSo record contains the following additional sections, most of which
deviate substantially from typical MOD files:

- *Instruments*, describing the samples and base tones associated with
  an instrument.

- *Timbres*, describing different volumes and vibrato styles for
  playing an instrument. Includes *Volume Envelopes*, which in turn
  are different (possibly infinite) sequences of volume information
  (in the sense of loudness).

- *Monopatterns*, which are compressed MOD-like "patterns", but for
  only one channel at a time.  They select notes, timbres, and effects.

- *Divisions* map the four Amiga channels to monopatterns, but can
  also apply transpose patterns or adjust their volume.

- *Songs*, the different songs stored in a CoSo file (in AmberStar,
  there seems to be only one song per file).

- *Samples*, pointers to audio samples in ~SAMPLEDA.IMG~.

These sections are in order, so that the corresponding position
markers also indicate the end of the preceding section:

| Section              | Offset          | Format  | Element Size | Number of Elements |
|----------------------+-----------------+---------+--------------+--------------------|
| Header               | 0               | single  |           32 | 1                  |
| Instruments          | pos_instruments | indexed |     variable | num_instruments    |
| Timbres              | pos_timbres     | indexed |     variable | num_timbres        |
| Monopatterns         | pos_patterns    | indexed |     variable | num_patterns       |
| Divisions            | pos_divisions   | array   |           12 | num_divisions      |
| Songs                | pos_song        | array   |            6 | num_songs          |
| Samples              | pos_samples     | array   |           10 | num_samples        |
| (end of CoSo record) | total_length    |         |              | 0                  |

All sections except for the header may store multiple elements.  The table above
indicates how the section encodes these elements:
- indexed: The section contains variable-length entries and uses an _index table_ (see below)
- array: The section contains fixed-length entries (of "Element Size" bytes) in sequence.

*** CoSo Index Tables

Three sections (*Instruments*, *Timbres*, *Monopatterns*) store
variable-length entries.  If we set ~num_elts~ to the number of
elements of that section (i.e., ~num_instruments~, ~num_timbres~, or
~num_patterns~), these sections have the following format:

| Name                  | Format                        | Comments                                      |
|-----------------------+-------------------------------+-----------------------------------------------|
| index[0]              | u16                           | relative to CoSo header                       |
| ...                   |                               |                                               |
| index[num_elts - 1]   | u16                           | relative to CoSo header                       |
| element[0]            | u8[index[1] - index[0]]       | variable length; meaning is section-dependent |
| ...                   |                               |                                               |
| element[num_elts - 1] | u8[end - index[num_elts - 1]] | variable length; meaning is section-dependent |

where ~end~ is the offset of the start of the next section.

The indices point directly into the ~elements~ block (relative to the
first CoSo header byte).

*** Song Semantics and Duration

The *Instruments*, *Timbres*, and *Monopatterns* sections contain
instructions that should be executed in sequence, and associated
timing information.  The programs for these three sections execute
concurrently but can reset each other in a number of ways; e.g., an
instrument can reset the current volume envelope program for the
active timbre, and a monopattern can set new instruments and volume
envelopes.

Program elements may have a duration, expressed in *ticks*.  One tick
has a duration of 0.02s, aligned with the timing of the PAL Amiga
screen redraw interrupt.

**** Notes, Pitch, and Period

The *period* is the amount of time allotted for playing a sample,
expressed in Amiga timer ticks.  The sample frequency is then the
number of times we can fit this period into one second's worth of
timer ticks:

  frequency = 3546894.6 / period

Adjusting this frequency allows adjusting the tone at which the sample
plays.

In CoSo, the period is determined by the _channel note_, which is the
sum of the following:
- *Instrument* pitch (which may be ~RELATIVE~ or ~ABSOLUTE~)
- *Monopattern* note (only with ~RELATIVE~ instrument pitch)
- *Division* transpose (only with ~RELATIVE~ instrument pitch)

Below are the note-to-period mappings, split by octave and semitone:

| Octave | st_0 | st_1 | st_2 | st_3 | st_4 | st_5 | st_6 | st_7 | st_8 | st_9 | st_10 | st_11 |
|--------+------+------+------+------+------+------+------+------+------+------+-------+-------|
|      0 | 1712 | 1616 | 1524 | 1440 | 1356 | 1280 | 1208 | 1140 | 1076 | 1016 |   960 |   906 |
|      1 |  856 |  808 |  762 |  720 |  678 |  640 |  604 |  570 |  538 |  508 |   480 |   453 |
|      2 |  428 |  404 |  381 |  360 |  339 |  320 |  302 |  285 |  269 |  254 |   240 |   226 |
|      3 |  214 |  202 |  190 |  180 |  170 |  160 |  151 |  143 |  135 |  127 |   120 |   113 |
|      4 |  113 |  113 |  113 |  113 |  113 |  113 |  113 |  113 |  113 |  113 |   113 |   113 |
|      5 | 3424 | 3232 | 3048 | 2880 | 2712 | 2560 | 2416 | 2280 | 2152 | 2032 |  1920 |  1812 |
|      6 | 6848 | 6464 | 6096 | 5760 | 5424 | 5120 | 4832 | 4560 | 4304 | 4064 |  3840 |  3624 |

In other words, the highest expected sampling rate is 31388 Hz, and the lowest is 518.

CoSo discards the most significant bit of the note (i.e., note 130 =
note 2).  Any notes outside the above table (i.e., >= 84) are mapped
to 0.

The resultant period may be further adjusted by
- *Vibrato*, and
- *Portando*
in that order, see below.

**** Vibrato

CoSo supports use a notion of *Vibrato* that modulates the audio
frequency with a saw-tooth pattern.  CoSo describes the saw-tooth
function via *slope* an *depth* parameters.

Let *period* = slope / depth (rounded up).  Then the saw-tooth
function has the form:

\(
  v(t) = \left \{ \begin{array}{l[]lcl} \max&(-\frac{\textsf{depth}}{2}, \phantom{-}\frac{depth}{2} - \textsf{slope} * (t \mod (\textbf{period} \times 2))) &\iff& t \mod \textbf{period}\textrm{ is even} \\
                                        \min&(\phantom{-}\frac{\textsf{depth}}{2}, -\frac{depth}{2} + \textsf{slope} * (t \mod (\textbf{period} \times 2))) &\iff& t \mod \textbf{period}\textrm{ is odd} \\ \end{array} \right .$
\)

(though tick counting seems to start at 1, meaning that v(0) is never used).

The *period* modulated by vibrato then becomes:

$\textbf{period}'(t) = \textbf{period} \times \left (1 + \frac{v(t)}{1024} \right )$

**** Portando

CoSo supports a linear variant of *Portando*, parameterised by
*portando_slope*.  The effect is defined as follows:

$p(t) = 1 - \frac{t \times \text{portando\_delta}}{1024}$

such that

$\textbf{period}''(t) = \textbf{period} \times  p(t)$

The Portando effect always applies after Vibrato.

**** Volume

CoSo uses Amiga volume levels, which range from 0 to 64.  A volume of 0 means "mute",
and volumes between 1 and 64 progress logarithmically wrt their dB values:

|  dB | Volume |
|-----+--------|
|   0 |     64 |
|  -6 |     32 |
| -12 |     16 |
| -18 |      8 |
| -24 |      4 |
| -30 |      2 |
| -36 |      1 |

The implications for mapping CoSo songs to PCM waveforms is that we
can interpret volume as a factor on all amplitudes, effectively
multiplying all amplitudes by ~volume / 64.0~.

In CoSo, the volume is the product of the following:
- *Volume Envelope* volume
- *Division* ~channel_volume~, interpreted as a percentage

**** Channels

CoSo supports four audio channels:

| Channel | Stereo output |
|---------+---------------|
|       0 | left          |
|       1 | right         |
|       2 | right         |
|       3 | left          |

Each channel maintains its individual state for *Instruments*,
*Timbres*, and *Monopatterns*.  Different channels may use the same
timbres etc. without affecting each other's state.

*Divisions* expose a structure that suggests that they synchronise
channels, but there does not seem to be any actual channel
synchronisation involved: if one channel's monopattern finishes before
another channel's, it may move on to the next division before the
other channels do.  (*TO VERIFY*)

*** Instruments

Instruments describe the "kind of tone" that the song should produce,
mainly in the form of sample and pitch information.

Each instrument is described in a variable-length byte sequence, encoding
various operations that describe the instrument.  By using timing delays,
instruments can vary their sample and pitch after being triggered.

The meanings of the bytes are below (in hexadecimal encoding):

| First Byte | Parameters                                                        | Operation                                                  | Duration | Notes               |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e0         | [pos:u8]                                                          | LOOP(pos)                                                  |        0 |                     |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e1         |                                                                   | COMPLETED                                                  | infinite |                     |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e2         | [sample:u8]                                                       | SAMPLE(sample, 1)                                          |        0 |                     |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e3         | [vslope:u8]  [vdepth:u8]                                          | ... unused: VIBRATO(vslope, vdepth) )                      |        0 | Unused in AmberStar |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e4         | [sample:d8]                                                       | ... unused: SAMPLE(num, 1)                                 |        0 | Unused in AmberStar |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e5         | [sample:u8]  [loop:u16]  [len>>1:u16]  [delta>>1:i16]  [speed:u8] | SAMPLE(sample, 1)                                          |        0 |                     |
|            |                                                                   | _if loop = 0xffff: SLIDE(len, sample.length, delta, speed) |          |                     |
|            |                                                                   | _otherwise:        SLIDE(len, loop << 1, delta, speed)     |          |                     |
|            |                                                                   | RESET-VOL                                                  |          |                     |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e6         | [len>>1:u16]  [delta>>1:i16]  [speed:u8]                          | ... unused: SLIDE(len, ?, delta, speed)                    |        0 | Unused in AmberStar |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e7         | [sample:u8]                                                       | SAMPLE(sample, 0)                                          |        0 |                     |
|            |                                                                   | RESET-VOL                                                  |          |                     |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e8         | [ticks:u8]                                                        | ... unused: INSTRUMENT-DELAY(ticks)                        |    ticks | Unused in AmberStar |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| e9         | [sample:u8]  [sample_offset:u8]                                   | ... unused: SAMPLE-CUSTOM(sample, sample_offset)           |        0 | Unused in AmberStar |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| [pitch:u8] | _if NOT pitch & 0x80                                              | PITCH(pitch, RELATIVE)                                     |        1 | Default case (1)    |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|
| [pitch:u8] | _if     pitch & 0x80                                              | PITCH(pitch & 0x7f, ABSOLUTE)                              |        1 | Default case (2)    |
|------------+-------------------------------------------------------------------+------------------------------------------------------------+----------+---------------------|

The operations above are detailed below:

- ~COMPLETED~: Instrument definition completed.

- ~LOOP(pos)~: Jump back to the byte position ~pos~ in this
  instrument's byte sequence to loop.

- ~PITCH(pitch, RELATIVE)~: Sets the instrument's pitch, effectively
  transposing the note that the instrument plays.  Not cumulative,
  i.e., overrides the previous pitch setting.  Wait one tick before
  continuing.

- ~PITCH(pitch, ABSOLUTE)~: Sets the _channel note_ directly.  This
  overrides *Monopattern* notes and *Division* transpose effects.
  Wait one tick before continuing.

- ~RESET-VOL~: Reset the volume envelope program in the current timbre
  to its starting position.

- ~SAMPLE(sample, reset_position)~: Switch to the specified ~sample~
  as the sample for this instrument.  If ~reset_position~ is ~1~ or if
  the sample is different from the previously assigned sample for this
  channel, also reset the sample's loop.

- ~SLIDE(len, loop, delta, speed)~: Interpret the current sample as a
  sample sequence, and "slide" across the sample data.  Specifically,
  loop from ~[loop..loop+len]~ within the sample, and after each
  ~speed~ ticks, update ~loop += delta~, unless this would take us
  outside the sample's data, at which point the loop window remains in
  position.  The effect of ~SLIDE~ ends as soon as the instrument's
  sample is changed.

The following operations seem unused in AmberStar and are therefore
less likely to be correct:

- ~INSTRUMENT-DELAY(ticks)~: Wait for the specified number of ticks before
  running the next operation.

- ~SAMPLE-CUSTOM(sample, offset)~: A variant of ~SAMPLE(sample, 1)~
  that seems to allow access to alternative start offset and loop
  information for the same sample data (read from from the *Samples*
  section).

- ~VIBRATO(vslope, vdepth)~: Update the current vibrato settings for this channel.

Each instrument ends with either ~COMPLETED~ or ~LOOP(_)~.

*** Timbres and Volume Envelopes

Timbres describe the volume and vibrato with which an instrument
should be played.  Each timbre begins with a header, followed by a
variable-length *Volume Envelope*.

A timbre header has the following format:

| Name          | Format | Comments                                                                                                    |
|---------------+--------+-------------------------------------------------------------------------------------------------------------|
| speed         | u8     | Default number of ticks between each step in the sound envelope                                             |
| instrument    | u8     | _if NOT instrument == 0x80: set instrument.  Monopatterns may override the instrument selecting the timbre. |
|               |        | _if     instrument == 0x80: keep current instrument and ignore any monopattern instrument override.         |
| vibrato_slope | u8     |                                                                                                             |
| vibrato_depth | u8     |                                                                                                             |
| vibrato_delay | u8     | Number of ticks before vibrato begins                                                                       |

The volume envelope follows immediately, and consists of bytes with
the following meaning:

| First Byte    | Parameters    | Meaning        | Duration | Notes                                          |
|---------------+---------------+----------------+----------+------------------------------------------------|
| e0            | [ticks:u8]    | SUSTAIN(ticks) | ticks    |                                                |
| e1, ..., e7   |               | HOLD           | infinite |                                                |
| e8            | [offset+5:u8] | LOOP(offset)   | 0        | Value is 5 bytes higher than the offset        |
| [volume:u8]   |               | VOLUME(volume) | speed    | Default case; "speed" is taken from the header |

- ~SUSTAIN(ticks)~ only delays processing the next step of the volume envelope.
- ~HOLD~ maintains the current volume level indefinitely.
- ~LOOP(offset)~ loops back to an earlier volume envelope entry.
- ~VOLUME(volume)~ sets the current base volume (which will be affected by the channel volume).

*** Monopatterns

Monopatterns encode a sequence of notes to play.  They again use a
sequential variable-length encoding:

| First Byte     | Parameters               | Operations                                                              | Duration | Notes                            |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| ff             |                          | END-PATTERN                                                             | 0        |                                  |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| fe             | [ticks:u8]               | SET-SPEED(ticks + 1)                                                    | 0        | pattern_speed := ticks + 1       |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| fd             | [ticks:u8]               | SET-SPEED(ticks + 1)                                                    | speed    | pattern_speed := ticks + 1       |
|                |                          | PATTERN-DELAY                                                           |          |                                  |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| [note:i8]      | [_info:u8]               | NOTE(note)                                                              | speed    | only note=0 appears in AmberStar |
| (if note <= 0) | (if NOT (_info & 0xe0)   |                                                                         |          |                                  |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| [note:i8]      | [_info:u8]  [info2:u8]   | NOTE(note)                                                              | speed    | only note=0 appears in AmberStar |
| (if note <= 0) | (if (_info & 0xe0)       |                                                                         |          |                                  |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| [note:u8]      | [timbre:u8]              | NOTE(note)                                                              | speed    | Default case (1)                 |
|                | (if NOT (timbre & 0xe0)  | TIMBRE(timbre + timbre_adjust, DEFAULT)                                 |          | timbre_adjust from *Division*    |
|----------------+--------------------------+-------------------------------------------------------------------------+----------+----------------------------------|
| [note:u8]      | [timbre:u8]  [effect:i8] | NOTE(note)                                                              | speed    | Default case (2)                 |
|                | (if (timbre & 0xe0)      | _if NOT timbre & 0x40: TIMBRE((timbre & 0x1f) + timbre_adjust, DEFAULT) |          | timbre_adjust from *Division*    |
|                |                          | _if     timbre & 0x40: TIMBRE((timbre & 0x1f) + timbre_adjust, effect)  |          |                                  |
|                |                          | _if timbre & 0x20: PORTANDO(effect)                                     |          |                                  |

Note that the ~speed~ in the above table is defined as:

  ~speed = pattern_speed * channel_speed~

where ~channel_speed~ is determined by the *Division* that triggered
this monopattern.

The explanations for the operations are below:

- ~END-PATTERN~: End of the monopattern.
- ~SET-SPEED(ticks)~: Sets the speed (in ticks) for all following ~PATTERN-DELAY~ and ~NOTE~ operations.
- ~PATTERN-DELAY~: Wait.
- ~NOTE(note)~: Set the current channel note.  Resets any current Portando effect.
- ~TIMBRE(timbre, DEFAULT)~: Set the channel's timbre.
- ~TIMBRE(timbre, instrument)~: Set the channel's timbre but override its instrument with the one specified here.
- ~PORTANDO(portando_slope)~: Activate portando for this note, with the given (i.e., recomputed) ~portando_slope~.

*** Divisions

Divisions are the highest-level units that make up a song.  Each
division maps all four channels to a monopattern, which in turn will
select timbre and instrument and play a sequence of notes.

Each division takes up twelve bytes; three for each channel ~c~,
from 0 to 3 (inclusive):

| Name           | Format | Comments                                   |
|----------------+--------+--------------------------------------------|
| monopattern[c] | u8     | Monopattern index to assign to the channel |
| transpose[c]   | i8     | Transpose for monopattern notes            |
| effect[c]      | u8     |                                            |

The effect can be one of the following:

| _if effect[c] = 0b0xxxxxxx | timbre_adjust := effect[c]         |
| _if effect[c] = 0b1000yyyy | FULL-STOP                          |
| _if effect[c] = 0b1110yyyy | channel_speed := 1 + 0byyyy        |
| _if effect[c] = 0b11110000 | channel_volume := 100              |
| _if effect[c] = 0b1111yyyy | channel_volume := (16 - 0byyy) * 6 |

- ~timbre_adjust~ shifts the *Timbres* selected by the *Monopattern* up by the given amount.
- ~channel_speed~ gives a factor for slowing down the notes across *all* channels
- ~FULL-STOP~: terminates the entire song.
- ~channel_volume~ permanently sets the channel's volume (as a percentage value).

Divisions play one monopattern on each of the channels until the
pattern's completion.  In principle, each channel might move onto the
next division, independently of each other, though in practice the
channels seem to be mapped to monopatterns of the same length (*TO VERIFY*).

The song terminates when the next division would be at or after the
~end~ of the Song.

*** Songs

Songs are encoded as follows:

| Name       | Format | Comments                                                   |
|------------+--------+------------------------------------------------------------|
| start      | u16    | byte index into the Division table: first division to play |
| end        | u16    | byte index into the Division table: end of song            |
| song_speed | u16    | initial ~channel_speed~ for all channels                   |

Initially, all channels are configured as follows:
- ~channel_volume~ = 100
- ~timbre_adjust~ = 0
- Vibrato disabled
- Portando disabled

*** Samples

Samples follow the following format:

| Name        | Format | Comments                            |
|-------------+--------+-------------------------------------|
| pos_sample  | u32    |                                     |
| length >> 1 | u16    | encoded as half of the actual value |
| pos_loop    | u16    |                                     |
| repeat >> 1 | u16    | encoded as half of the actual value |

The sample ranges from ~pos_sample..pos_sample + length - 1~.
Once the sample has played through once, it will loop from
~pos_loop..pos_loop + repeat - 1~.

*** CoSo Notes

The information above was reconstructed from a variety of sources and
from experiments and (moderately)  educated guesses.

CoSo (also known as Hippel-CoSo in the Amiga MOD community) is a
custom MOD-like song format used by Jochen Hippel's Amiga compositions
e.g. for Thalion.  The format seems to have evolved over the years, so
the above format description may not fit other CoSo songs.


